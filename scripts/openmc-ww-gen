#!/usr/bin/env python

from argparse import ArgumentParser
import argparse
from copy import deepcopy

import numpy as np
import openmc
import openmc.lib
from openmc.mpi import comm


def magic(model, tally_id, iterations, rel_err_tol=0.7):
    """
    Performs weight window generation using the MAGIC method

    Davis, A., & Turner, A. (2011). Comparison of global variance reduction
    techniques for Monte Carlo radiation transport simulations of ITER. Fusion
    Engineering and Design, 86, 2698â€“2700.
    https://doi.org/10.1016/j.fusengdes.2011.01.059

    Parameters
    ----------

    model : openmc.Model
        The OpenMC model to run
    tally : int
        The tally ID to use for weight window generation
    iterations : int
        The number of iterations to perform
    rel_err_tol : float (default: 0.7)
        Upper limit on relative error of flux values used to produce
        weight windows.
    """

    # determine the name of the statepoint file
    # that will be generated by a run
    statepoint_name = f'statepoint.{model.settings.batches}.h5'

    if comm.rank == 0:
        model.export_to_xml()
    comm.barrier()

    ww_gen = update_wws(model, statepoint_name, tally_id, rel_err_tol)

    for i in range(iterations):
        _magic_inner(ww_gen)


def _magic_inner(ww_generator):
    """
    Internal function for the MAGIC method
    """
    # run the model
    openmc.lib.init()
    openmc.lib.run()
    openmc.lib.finalize()

    if comm.rank == 0:
        next(ww_generator)
    comm.barrier()


def update_wws(model, statepoint_name, tally_id, rel_err_tol):

    # get some information about the tally
    tally, mesh_filter, e_bounds, particles = _get_tally_info(statepoint_name, tally_id)

    n_mesh_bins = mesh_filter.num_bins
    n_e_groups = len(e_bounds) - 1

    # determine the size of the mean and std. dev. arrays
    sum = dict()
    sum_sq = dict()

    for particle in particles:
        sum[particle] = np.zeros((mesh_filter.num_bins, n_e_groups))
        sum_sq[particle] = np.zeros((mesh_filter.num_bins, n_e_groups))

    N = 0

    while(True):

        N += 1

        # get the tally from the statepoint file
        tally, mesh_filter, e_bounds, particles = _get_tally_info(statepoint_name, tally_id)

        wws = []
        for particle in particles:
            get_value_args = (['flux'], [openmc.ParticleFilter], [(particle,)])
            flux_mean = tally.get_values(*get_value_args)
            flux_mean = flux_mean.reshape(sum[particle].shape)
            # update old values
            sum[particle] += flux_mean
            sum_sq[particle] += flux_mean**2

            if N > 1:
                mean = sum[particle] / N
                rel_err = (sum_sq[particle]/N) - (mean**2)/(N-1)
            else:
                mean = flux_mean
                rel_err = tally.get_values(*get_value_args, value='rel_err').reshape(sum[particle].shape)

            # filter out values with high relative error
            filter_indices = np.logical_and(rel_err > rel_err_tol, np.isfinite(rel_err))
            mean[filter_indices] = 0.0

            # generate lower_ww_bound values for the weight windows for each energy group
            mean = mean.reshape((n_mesh_bins, n_e_groups))

            lower_ww_bnds = np.zeros_like(mean)

            flux_max = np.amax(mean)

            if flux_max == 0.0:
                raise RuntimeError("Specified tally has a zero score.")

            # make a copy of the mesh to circumvent problems with the
            # same mesh written to multiple input files
            mesh_copy = deepcopy(mesh_filter.mesh)
            mesh_copy.id = None

            for i in range(n_e_groups):
                indices = (slice(None), i)
                group_flux = mean[indices]

                group_max = np.amax(group_flux)

                if group_max == 0.0:
                    continue

                # normalize to max weight window value of 0.5
                lower_ww_bnds[indices] = group_flux / group_max
                lower_ww_bnds[indices] *= 0.5

                lower_ww_bnds[lower_ww_bnds <= 0.0] = -1

                # create weight window settings
                ww = openmc.WeightWindows(mesh_copy,
                                          lower_ww_bnds.flatten(),
                                          None,
                                          10.0,
                                          e_bounds,
                                          particle)
                # create the weight window domain
                wws.append(ww)

        model.settings.weight_windows = wws
        model.export_to_xml()

        yield


def _get_tally_info(statepoint_name, tally_id):

    with openmc.StatePoint(statepoint_name) as sp:
        tally = sp.tallies[tally_id]
        # find the mesh used on the tally
        try:
            mesh_filter = tally.find_filter(openmc.MeshFilter)
            mesh = mesh_filter.mesh
        except ValueError as e:
            msg = ('The MAGIC method requires that a mesh is present on the tally')
            raise e(msg)

        # check for an energy filter on the tally
        try:
            ef = tally.find_filter(openmc.EnergyFilter)
            n_e_groups = ef.num_bins
            e_groups = np.unique(ef.bins.flatten())
        except ValueError:
            n_e_groups = 1
            e_groups = [0, 1E40]

        if 'flux' not in tally.scores:
            msg = ('The MAGIC method requires a flux score on the tally. '
                'No flux score is present on tally with ID {}')
            raise ValueError(msg.format(tally_id))

        try:
            pf = tally.find_filter(openmc.ParticleFilter)
            particles = pf.bins # TODO: support multiple particle types
        except ValueError:
            particles = ['neutron']

        return tally, mesh_filter, e_groups, particles


if __name__ == '__main__':
    ap = ArgumentParser("Applies MAGIC method to a local OpenMC model.")
    ap.add_argument('t', type=int, help='ID of the tally to use for weight window generation')
    ap.add_argument('n', type=int, help='Number of iterations to perform')
    ap.add_argument('r', type=float, default=0.7, help='Relative error tolerance')

    args = ap.parse_args()

    model = openmc.Model.from_xml()

    magic(model, args.t, args.n, args.r)
