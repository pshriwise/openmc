#!/usr/bin/env python

from collections import OrderedDict

from argparse import ArgumentParser
import argparse
from copy import deepcopy

import numpy as np
import openmc
import openmc.lib
from openmc.mpi import comm

_ALLOWED_FILTER_TYPES = (openmc.MeshFilter, openmc.EnergyFilter, openmc.ParticleFilter)

def magic(model, tally_id, iterations, rel_err_tol=0.7):
    """
    Performs weight window generation using the MAGIC method

    Davis, A., & Turner, A. (2011). Comparison of global variance reduction
    techniques for Monte Carlo radiation transport simulations of ITER. Fusion
    Engineering and Design, 86, 2698â€“2700.
    https://doi.org/10.1016/j.fusengdes.2011.01.059

    Parameters
    ----------

    model : openmc.Model
        The OpenMC model to run
    tally : int
        The tally ID to use for weight window generation
    iterations : int
        The number of iterations to perform
    rel_err_tol : float (default: 0.7)
        Upper limit on relative error of flux values used to produce
        weight windows.
    """

    check_tally(model, tally_id)

    if comm.rank == 0:
        model.export_to_xml()
    comm.barrier()

    for _ in range(iterations):
        openmc.run()

        if comm.rank == 0:
            wws = generate_wws(model, tally_id, rel_err_tol)
            model.settings.weight_windows = wws
            model.export_to_xml()


def check_tally(model, tally_id):

    for tally in model.tallies:
        if tally.id == tally_id:
            break

    if tally.id != tally_id:
        raise RuntimeError(f'No tally with ID "{tally_id}" is present in the model.')

    filter_types = tuple(type(f) for f in tally.filters)

    if openmc.MeshFilter not in filter_types:
        raise ValueError('This script requires a MeshFilter on the specified tally')

    if filter_types != _ALLOWED_FILTER_TYPES[:len(filter_types)]:
        raise RuntimeError(f'This script accepts the following types: {_ALLOWED_FILTER_TYPES}\n in that order. '
        'Only the MeshFilter is required.')

def generate_wws(model, tally_id, rel_err_tol):
    """
    Generates weight windows based on a tally.

    Returns
    -------
    Iterable of openmc.WeightWindows
    """

    # determine the name of the statepoint file
    # that will be generated by a run
    sp_file = f'statepoint.{model.settings.batches}.h5'

    with openmc.StatePoint(sp_file) as sp:
        tally = sp.get_tally(id=tally_id)

    filter_types = [type(f) for f in tally.filters]

    for ft in filter_types:
        if ft not in _ALLOWED_FILTER_TYPES:
            raise ValueError(f'Filter type {ft} is unsupported for weight window generation')

    mesh_filter = tally.find_filter(openmc.MeshFilter)
    mesh = mesh_filter.mesh
    mesh_copy = deepcopy(mesh)

    # get the tally mean and relative error
    mean = tally.get_reshaped_data()
    rel_err = tally.get_reshaped_data(value='rel_err')

    # in case other scores are applied to this tally,
    # make sure to use the correct index for "flux"
    score_idx = tally.get_score_index("flux")

    mean = mean[..., score_idx]
    rel_err = rel_err[..., score_idx]

    # in case other nuclides are applied to this tally,
    # make sure to use the 'total' nuclide entry
    nuclide_idx = tally.get_nuclide_index("total")

    mean = mean[..., nuclide_idx]
    rel_err = rel_err[..., nuclide_idx]

    # sanity check: number of dimensions should now be no more than three
    assert mean.ndim <= 3

    # make sure there are three dimensions
    if openmc.EnergyFilter not in filter_types:
        mean = np.expand_dims(mean, 1)
        rel_err = np.expand_dims(rel_err, 1)

    if openmc.ParticleFilter not in filter_types:
        mean = np.expand_dims(mean, 2)
        rel_err = np.expand_dims(rel_err, 2)

    assert mean.ndim == 3

    if openmc.EnergyFilter not in filter_types:
        n_e_bins = 1
        e_bounds = [0, 1e40]
    else:
        e_filter = tally.find_filter(openmc.EnergyFilter)
        e_bounds = e_filter.values
        n_e_bins = e_filter.num_bins

    if openmc.ParticleFilter not in filter_types:
        particles = ['neutron']
    else:
        p_filter = tally.find_filter(openmc.ParticleFilter)
        particles = p_filter.bins


    wws = []

    mean = mean.T
    rel_err = rel_err.T
    print(f'Mean shape: {mean.shape}')

    # loop over particle data
    for particle, p_mean, p_rel_err in zip(particles, mean, rel_err):
        print(f'p_mean shape: {p_mean.shape}')
        print(n_e_bins)
        ww_lower_bounds = np.empty((*mesh.dimension, n_e_bins), dtype=float)

        for i, (e_mean, e_rel_err) in enumerate(zip(p_mean, p_rel_err)):
            print(f'e_mean shape: {e_mean.shape}')
            # now we should be working with mesh data
            e_mean = e_mean / np.max(e_mean)

            e_mean[(e_mean == 0) | (e_rel_err > rel_err_tol)] = -1.0
            e_mean[~np.isfinite(e_mean)] = -1.0

            e_mean = e_mean.reshape(mesh.dimension[::-1]).T
            ww_lower_bounds[..., i] = e_mean


        print(ww_lower_bounds.shape)
        p_weight_windows = openmc.WeightWindows(mesh_copy,
                                                ww_lower_bounds,
                                                upper_bound_ratio=5.0,
                                                energy_bounds=e_bounds,
                                                particle_type=particle)

        wws.append(p_weight_windows)

    return wws


def _magic_inner(ww_generator):
    """
    Internal function for the MAGIC method
    """
    # run the model
    openmc.lib.init()
    openmc.lib.run()
    openmc.lib.finalize()

    if comm.rank == 0:
        next(ww_generator)
    comm.barrier()

def update_wws(model, tally_id, rel_err_tol):

    # determine the name of the statepoint file
    # that will be generated by a run
    statepoint_name = f'statepoint.{model.settings.batches}.h5'

    # get some information about the tally
    tally, mesh_filter, e_bounds, particles = _get_tally_info(statepoint_name, tally_id)

    n_mesh_bins = mesh_filter.num_bins
    n_e_groups = len(e_bounds) - 1

    # determine the size of the mean and std. dev. arrays
    sum = dict()
    sum_sq = dict()

    for particle in particles:
        sum[particle] = np.zeros((mesh_filter.num_bins, n_e_groups), type=float)
        sum_sq[particle] = np.zeros((mesh_filter.num_bins, n_e_groups), type=float)

    N = 0

    while(True):

        N += 1

        wws = []
        for particle in particles:
            get_value_args = (['flux'], [openmc.ParticleFilter], [(particle,)])
            flux_mean = tally.get_values(*get_value_args)
            flux_mean = flux_mean.reshape(sum[particle].shape)



            # update the current mean and rel. err. over all runs
            if N > 1:
                mean = sum[particle] / N
                rel_err = (sum_sq[particle]/N) - (mean**2)/(N-1)
            else:
                mean = flux_mean
                rel_err = tally.get_values(*get_value_args, value='rel_err').reshape(sum[particle].shape)

            # filter out values with high relative error
            filter_indices = np.logical_and(rel_err > rel_err_tol, np.isfinite(rel_err))
            mean[filter_indices] = 0.0



            # generate lower_ww_bound values for the weight windows for each energy group
            mean = mean.reshape((n_mesh_bins, n_e_groups))

            lower_ww_bnds = np.zeros_like(mean, )

            flux_max = np.amax(mean)

            if flux_max == 0.0:
                raise RuntimeError("Specified tally has a zero score.")

            # make a copy of the mesh to circumvent problems with the
            # same mesh written to multiple input files
            mesh_copy = deepcopy(mesh_filter.mesh)
            mesh_copy.id = None

            for i in range(n_e_groups):
                indices = (slice(None), i)
                group_flux = mean[indices]

                group_max = np.amax(group_flux)

                if group_max == 0.0:
                    continue

                # normalize to max weight window value of 0.5
                lower_ww_bnds[indices] = group_flux / group_max
                lower_ww_bnds[indices] *= 0.5

                lower_ww_bnds[lower_ww_bnds <= 0.0] = -1

            # create weight window settings
            ww = openmc.WeightWindows(mesh_copy,
                                      lower_ww_bnds.flatten(),
                                      None,
                                      10.0,
                                      e_bounds,
                                      particle)
            # create the weight window domain
            wws.append(ww)

        model.settings.weight_windows = wws
        model.export_to_xml()

        yield


def _get_tally_info(statepoint_name, tally_id):

    with openmc.StatePoint(statepoint_name) as sp:
        tally = sp.tallies[tally_id]
        # find the mesh used on the tally
        try:
            mesh_filter = tally.find_filter(openmc.MeshFilter)
            mesh = mesh_filter.mesh
        except ValueError as e:
            msg = ('The MAGIC method requires that a mesh is present on the tally')
            raise e(msg)

        # check for an energy filter on the tally
        try:
            ef = tally.find_filter(openmc.EnergyFilter)
            n_e_groups = ef.num_bins
            e_groups = ef.values
        except ValueError:
            n_e_groups = 1
            e_groups = [0, 1E40]

        if 'flux' not in tally.scores:
            msg = ('The MAGIC method requires a flux score on the tally. '
                'No flux score is present on tally with ID {}')
            raise ValueError(msg.format(tally_id))

        try:
            pf = tally.find_filter(openmc.ParticleFilter)
            particles = pf.bins # TODO: support multiple particle types
        except ValueError:
            particles = ['neutron']

        return tally, mesh_filter, e_groups, particles


if __name__ == '__main__':
    ap = ArgumentParser("Applies MAGIC method to a local OpenMC model.")
    ap.add_argument('t', type=int, help='ID of the tally to use for weight window generation')
    ap.add_argument('n', type=int, help='Number of iterations to perform')
    ap.add_argument('r', type=float, default=0.7, help='Relative error tolerance')

    args = ap.parse_args()

    model = openmc.Model.from_xml()

    magic(model, args.t, args.n, args.r)
