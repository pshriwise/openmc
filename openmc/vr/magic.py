from copy import deepcopy
import numpy as np

import openmc

def magic(model, tally_id, iterations):
    """
    Performs weight window generation using the MAGIC method

    Davis, A., & Turner, A. (2011). Comparison of global variance reduction
    techniques for Monte Carlo radiation transport simulations of ITER. Fusion
    Engineering and Design, 86, 2698â€“2700.
    https://doi.org/10.1016/j.fusengdes.2011.01.059

    Parameters
    ----------

    model : openmc.Model
        The OpenMC model to run
    tally : int
        The tally ID to use for weight window generation
    iterations : int
        The number of iterations to perform
    """

    # determine the name of the statepoint file
    # that will be generated by a run
    statepoint_name = f'statepoint.{model.settings.batches}.h5'

    for i in range(iterations):
        _magic_inner(model, statepoint_name, tally_id)


def _magic_inner(model, statepoint_name, tally_id):
    """
    Internal function for the MAGIC method
    """
    # run the model
    model.run()

    # get the tally from the statepoint file
    with openmc.StatePoint(statepoint_name) as sp:
        tally = sp.tallies[tally_id]

        # find the mesh used on the tally
        try:
            mesh = tally.find_filter(openmc.MeshFilter).mesh
        except ValueError as e:
            msg = ('The MAGIC method requires that a mesh is present on the tally')
            raise e(msg)

        # check for an energy filter on the tally
        try:
            ef = tally.find_filter(openmc.EnergyFilter)
            n_e_groups = ef.num_bins
            e_groups = np.unique(ef.bins.flatten())
        except ValueError:
            n_e_groups = 1
            e_groups = [0, 1E40]

        if 'flux' not in tally.scores:
            msg = ('The MAGIC method requires a flux score on the tally. '
                   'No flux score is present on tally with ID {}')
            raise ValueError(msg.format(tally_id))

        try:
            pf = tally.find_filter(openmc.ParticleFilter)
            particle = pf.bins[0] # TODO: support multiple particle types
        except ValueError:
            particle = 'neutron'

    flux_mean = tally.get_values(scores=['flux'])
    flux_rel_err = tally.get_values(scores=['flux'], value='rel_err')

    # filter out values with high relative error
    rel_err_tol = 0.4
    filter_indices = np.logical_and(flux_rel_err > rel_err_tol, np.isfinite(flux_rel_err))
    flux_mean[filter_indices] = 0.0

    # generate lower_ww_bound values for the weight windows for each energy group

    flux_mean = flux_mean.reshape((*mesh.dimension, n_e_groups))

    lower_ww_bnds = np.zeros_like(flux_mean)

    for i in range(n_e_groups):
        indices = (slice(None),) * len(mesh.dimension) + (i,)
        group_flux = flux_mean[indices]

        group_max = np.amax(group_flux)

        if group_max == 0.0:
            continue

        # normalize to max weight window value of 0.5
        lower_ww_bnds[indices] = group_flux / group_max
        lower_ww_bnds[indices] *= 0.5

    # create weight window settings
    wws = openmc.WeightWindowSettings(None, particle, e_groups, lower_ww_bnds.flatten(), 5.0)

    # make a copy of the mesh to circumvent problems with the
    # same mesh written to multiple input files
    mesh_copy = deepcopy(mesh)
    mesh_copy.id += 1

    # create the weight window domain
    wwd = openmc.WeightWindowDomain(None, mesh_copy, wws)

    # export variance reduction properties
    vr = openmc.VarianceReduction()
    vr.weight_window_domains = [wwd]
    vr.export_to_xml()
